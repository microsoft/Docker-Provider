# Starter pipeline
# Start with a minimal pipeline that you can customize to build and deploy your code.
# Add steps that build, run tests, deploy, and more:
# https://aka.ms/yaml

trigger:
  batch: true
  branches:
    include:
    - ai_prod
  tags:
    include:
    - '*-appmonitoring'

variables:
  armServiceConnectionName: 'Appmonitoring_AKS_connection'
  subscription: '5a3b3ba4-3a42-42ae-b2cb-f882345803bc'
  containerRegistry: 'aicommon' # this build pushes the aidev image to the dev ACR (caution: ACR that has "prod" in its name is the dev one, the one without "prod" is prod AME)
  repoImageName: '${{ variables.containerRegistry }}.azurecr.io/public/azuremonitor/applicationinsights/aidev'
  IS_PR: $[eq(variables['Build.Reason'], 'PullRequest')]

jobs:
- job: common
  variables:
    Codeql.SkipTaskAutoInjection: true
  pool:
    name: rambhatt-test-es-pool
  steps:
  - checkout: self
    fetchDepth: 0
    fetchTags: true
  - task: ComponentGovernanceComponentDetection@0
  ## dev builds are in format Major.Minor.Patch-CommitAheadCount-CommitId
  ## prod release are in format Major.Minor.Patch
  ## preview release are in format preview-Major.Minor.Patch
  - bash: |
      commit=$(git describe --tags)
      imageTag="$commit"
            
      echo "imageTag is $imageTag"
      
      echo "##vso[task.setvariable variable=imageTag;isOutput=true]$imageTag"
      
      cd $(Build.SourcesDirectory)/deployment/mergebranch-webhook-deployment/ServiceGroupRoot/Scripts
    name: setup

- job: build_linux
  
  timeoutInMinutes: 120
  dependsOn: common
  pool:
    name: rambhatt-test-es-pool
  variables:
    imageTag: $[ dependencies.common.outputs['setup.imageTag'] ]
    testImageName: ${{ variables.repoImageName }}-test:$(imageTag)-$(Build.BuildId)
    fullImageName: ${{ variables.repoImageName }}:$(imageTag)
    javaTestAppImageName: 'aicommon.azurecr.io/demoaks-java-app:latest'
    javaTestAppName: 'test-app-java'
    nodeTestAppImageName: 'aicommon.azurecr.io/demoaks-nodejs-app:latest'
    nodeTestAppName: 'test-app-nodejs'
    testNamespace: 'test-ns'
    aiConnectionString: 'InstrumentationKey=2b453402-fcfb-408f-8495-c551f0e82f46;IngestionEndpoint=https://eastus-8.in.applicationinsights.azure.com/;LiveEndpoint=https://eastus.livediagnostics.monitor.azure.com/'
    aiResourceId: '/subscriptions/5a3b3ba4-3a42-42ae-b2cb-f882345803bc/resourceGroups/aks-appmonitoring-pipeline/providers/microsoft.insights/components/appmonitoring-pipeline-validation-ai'
    Codeql.Enabled: true
    Codeql.BuildIdentifier: 'linuxbuild'
    AKSResourceGroup: 'aks-appmonitoring-pipeline'
    AKSResourceName: 'appmonitoring-webhook-testbed'
    # This is necessary because of: https://github.com/moby/moby/issues/37965
    DOCKER_BUILDKIT: 1

  steps:
  - task: CodeQL3000Init@0
  - task: AzureCLI@2
    displayName: "Ready Image and push to ACR"
    inputs:
      azureSubscription: ${{ variables.armServiceConnectionName }}
      scriptType: bash
      scriptLocation: inlineScript
      inlineScript: |
        mkdir -p $(Build.ArtifactStagingDirectory)/linux

        echo "Installing NPM..."
        sudo apt-get -y install npm

        echo "Switching the directory..."
        cd appmonitoring/ts/src
        pwd
        ls -a
        
        echo "Installing npm packages..."
        sudo npm install

        #echo "Updating packages..."
        #npm update
        
        echo "Building the typescript project..."
        tsc --build --force
        
        if [ $? -ne 0 ]
        then
          echo "Build failed"
          exit 1
        fi

        echo "Build is done"

        echo "Running ESLint..."
        npx eslint .

        if [ $? -ne 0 ]
        then
          echo "ESLint failed"
          exit 1
        fi

        echo "ESLint is done"

        echo "Running Jest..."
        npm test

        if [ $? -ne 0 ]
        then
          echo "Jest failed"
          exit 1
        fi

        echo "Jest is done"
        
        pwd
        ls -a
        
        sudo apt-get update && sudo apt-get -y install qemu binfmt-support qemu-user-static
        docker run --rm --privileged multiarch/qemu-user-static --reset -p yes

        docker buildx create --name testbuilder
        docker buildx use testbuilder

        az --version
        az account show
        az account set -s ${{ variables.subscription }}
        az acr login -n ${{ variables.containerRegistry }}

        echo "Build reason = $(Build.Reason)"

        echo ${{ variables.testImageName }}
        
        docker buildx build --platform linux/amd64,linux/arm64 --tag ${{ variables.testImageName }} -f ./Dockerfile --metadata-file $(Build.ArtifactStagingDirectory)/linux/metadata.json --push --provenance=false .
        docker pull ${{ variables.testImageName }}

  - task: AzureCLI@2
    displayName: "Create deployment in AKS"
    inputs:
      azureSubscription: ${{ variables.armServiceConnectionName }}
      scriptType: bash
      scriptLocation: inlineScript
      inlineScript: |
        cd appmonitoring/validation-helm
        pwd
        az account set --subscription ${{ variables.subscription }}
        az aks get-credentials --resource-group ${{ variables.AKSResourceGroup }} --name ${{ variables.AKSResourceName }} 
        kubectl delete -f appmonitoring-deployment.yaml

        echo "Wait for 10s for everything to clear up..."
        sleep 10

        export AIDEV_IMAGE_NAME=${{ variables.testImageName }}
        cat appmonitoring-deployment.yaml | envsubst | kubectl apply -f -

        echo "Wait for 10s for charts to be applied..."
        sleep 10

  - task: AzureCLI@2
    displayName: "Validate charts deployed to AKS"
    inputs:
      azureSubscription: ${{ variables.armServiceConnectionName }}
      scriptType: bash
      scriptLocation: inlineScript
      inlineScript: |
        cd appmonitoring/scripts
        pwd
        az account set --subscription ${{ variables.subscription }}
        az aks get-credentials --resource-group ${{ variables.AKSResourceGroup }} --name ${{ variables.AKSResourceName }} 

        sudo chmod u+x ./validate-aks-charts.sh
        sudo chmod u+x ./validate-certs.sh

        echo "Checking for charts..."
        ./validate-aks-charts.sh
        
        echo "Checking for certificate installation..."
        ./validate-certs.sh

  - task: AzureCLI@2
    displayName: "Install CR and test apps"
    inputs:
      azureSubscription: ${{ variables.armServiceConnectionName }}
      scriptType: bash
      scriptLocation: inlineScript
      inlineScript: |
        cd appmonitoring/validation-helm
        pwd
        az account set --subscription ${{ variables.subscription }}
        az aks get-credentials --resource-group ${{ variables.AKSResourceGroup }} --name ${{ variables.AKSResourceName }} 

        export JAVA_TEST_IMAGE_NAME=${{ variables.javaTestAppImageName }}
        export NODEJS_TEST_IMAGE_NAME=${{ variables.nodeTestAppImageName }}
        export TEST_NS="${{ variables.testNamespace }}"
        export AI_CONNECTION_STRING="${{ variables.aiConnectionString }}"
        export JAVA_TEST_APP_NAME="${{ variables.javaTestAppName }}"
        export NODEJS_TEST_APP_NAME="${{ variables.nodeTestAppName }}"

        cat java-test-app.yaml | envsubst | kubectl delete -f -
        cat node-test-app.yaml | envsubst | kubectl delete -f -
        cat appmonitoring-cr.yaml | envsubst | kubectl delete -f -

        echo "Wait for 10s for everything to clear up..."
        sleep 10

        kubectl create namespace $TEST_NS

        cat appmonitoring-cr.yaml | envsubst | kubectl apply -f -
        echo "Wait for 10s for CR to be applied and picked up..."
        sleep 10

        cat java-test-app.yaml | envsubst | kubectl apply -f -
        cat node-test-app.yaml | envsubst | kubectl apply -f -

        echo "Wait for 60s for charts to be applied..."
        sleep 60

  - task: AzureCLI@2
    displayName: "Check test apps were mutated correctly"
    inputs:
      azureSubscription: ${{ variables.armServiceConnectionName }}
      scriptType: bash
      scriptLocation: inlineScript
      inlineScript: |
        cd appmonitoring/scripts
        pwd
        az account set --subscription ${{ variables.subscription }}
        az aks get-credentials --resource-group ${{ variables.AKSResourceGroup }} --name ${{ variables.AKSResourceName }}
        
        sudo chmod u+x ./validate-mutation.sh
        ./validate-mutation.sh "test-app-java" "test-app-nodejs" "test-ns"

  - task: AzureCLI@2
    displayName: "Check test apps are sending telemetry to AI"
    inputs:
      azureSubscription: ${{ variables.armServiceConnectionName }}
      scriptType: bash
      scriptLocation: inlineScript
      inlineScript: |
        cd appmonitoring/scripts
        pwd
        az account set --subscription ${{ variables.subscription }}
        az aks get-credentials --resource-group ${{ variables.AKSResourceGroup }} --name ${{ variables.AKSResourceName }} 
        export JAVA_TEST_APP_NAME="${{ variables.javaTestAppName }}"
        export NODEJS_TEST_APP_NAME="${{ variables.nodeTestAppName }}"

        echo "Wait for 3m for telemetry to flow..."
        sleep 180
        
        sudo chmod u+x ./validate_ai.sh
        ./validate_ai.sh "test-app-java" "test-app-nodejs" "${{ variables.aiResourceId }}" "test-ns"

  - task: AzureCLI@2
    displayName: "Retag the image as ready to deploy"
    inputs:
      azureSubscription: ${{ variables.armServiceConnectionName }}
      scriptType: bash
      scriptLocation: inlineScript
      inlineScript: |
        az --version
        az account show
        az account set -s ${{ variables.subscription }}
        az acr login -n ${{ variables.containerRegistry }}

        docker pull ${{ variables.testImageName }}
        docker tag ${{ variables.testImageName }} ${{ variables.fullImageName }}
        docker push ${{ variables.fullImageName }}
        
  - task: CodeQL3000Finalize@0






