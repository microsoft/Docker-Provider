apiVersion: batch/v1beta1
kind: CronJob
metadata:
  name: appmonitoring-cert-housekeeper-hook
  namespace: kube-system
  annotations:
    "helm.sh/hook": post-install
  labels:
    component: app-monitoring
spec:
  schedule: "*/5 * * * *"
  activeDeadlineSeconds: 600
  jobTemplate:
    spec:
      template:
        spec:
          affinity:
            nodeAffinity:
              requiredDuringSchedulingIgnoredDuringExecution:
                nodeSelectorTerms:
                - matchExpressions:
                  - key: kubernetes.io/os
                    operator: In
                    values:
                    - linux
                  - key: kubernetes.azure.com/cluster
                    operator: Exists
                  - key: type
                    operator: NotIn
                    values:
                    - virtual-kubelet
              preferredDuringSchedulingIgnoredDuringExecution:
              - weight: 100
                preference:
                  matchExpressions:
                  - key: kubernetes.azure.com/mode
                    operator: In
                    values:
                    - system
          tolerations:
            - key: "CriticalAddonsOnly"
              operator: "Exists"
            - operator: "Exists"
              effect: NoExecute
            - operator: "Exists"
              effect: NoSchedule
            - operator: "Exists"
              effect: PreferNoSchedule
          serviceAccountName: app-monitoring-webhook-sa
          containers:
            - env:
              - name: CONTAINER_MODE
                value: secrets-housekeeper
              image: ${AIDEV_IMAGE_NAME}
              imagePullPolicy: Always
              name: app-monitoring-cert-manager
          restartPolicy: OnFailure
---
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  name: instrumentations.monitor.azure.com # name must match the spec fields below, and be in the form: <plural>.<group>
spec:
  group: monitor.azure.com # group name to use for REST API: /apis/<group>/<version>
  names:
    plural: instrumentations # plural name to be used in the URL: /apis/<group>/<version>/<plural>
    singular: instrumentation # singular name to be used as an alias on the CLI and for display
    kind: Instrumentation # kind is normally the PascalCase singular type. Your resource manifests use this.
  scope: Namespaced # either Namespaced or Cluster
  versions:
    - name: v1
      served: true # each version can be enabled/disabled. Defines whether k8s will serve this version to clients if asked to.
      storage: true # one and only one version must be marked as the storage version. This is how all CRs will be stored internally when crated.
      schema:
        openAPIV3Schema:
          description: >-
            Configures application monitoring in the current namespace. Multiple CRs of this kind are allowed within a namespace. 
            
            CR named _default_ will be used for every workload in the namespace unless speicifically overridden through annotations.
            To use a different CR _crName_ for a particular workload, mark it with _instrumentation.opentelemetry.io/inject-\<language\>="\<crName\>"_ annotation.

            Multiple annotations (for different languages) may be applied to the same workload. Annotations must be placed at the workload's spec level (_spec.template.metadata.annotations_) level. Currently, only deployments are supported.
            
            Examples of annotation usage:

            instrumentation.opentelemetry.io/inject-java="true"
            Uses the default CR for the namespace with Java instrumentation (regardless of which languages the default CR specifies)

            instrumentation.opentelemetry.io/inject-java="false"
            Disables all instrumentation regardless of which languages the default CR specifies, or which language-specific annotation is used.

            instrumentation.opentelemetry.io/inject-java="true"
            instrumentation.opentelemetry.io/inject-dotnet="true"
            Uses the default CR for the namespace with Java and .NET instrumentation (regardless of which languages the default CR specifies)

            instrumentation.opentelemetry.io/inject-java="true"
            instrumentation.opentelemetry.io/inject-dotnet="false"
            Uses the default CR for the namespace with Java (regardless of which languages the default CR specifies)

            instrumentation.opentelemetry.io/inject-java="alternativeCrInThisNamespace"
            Uses a different, non-default CR named _alternativeCrInThisNamespace_ found within the namespace with Java instrumentation (regardless of which languages that CR specifies)

            instrumentation.opentelemetry.io/inject-java="crName1"
            instrumentation.opentelemetry.io/inject-dotnet="crName2"
            Invalid configuration, deployment will fail.

            instrumentation.opentelemetry.io/inject-dotnet="crThatDoesNotExist"
            Invalid configuration since the CR does not exist, deployment will continue with no instrumentation.
          type: object
          required:
            - spec
          properties:
            spec:
              type: object
              required: 
                - settings
                - destination
              properties:
                settings:
                  description: Determines which settings to apply as part of this configuration.
                  type: object
                  required:
                    - autoInstrumentationPlatforms
                  properties:
                    imageRepoPath:
                      description: "Path to a repository to fetch auto-instrumentation images from. Only use if you have an Artifact Cache set up to host related images normally found on Microsoft Container Registry (MCR). See here for details: https://learn.microsoft.com/en-us/azure/container-registry/tutorial-artifact-cache"
                      type: string
                    autoInstrumentationPlatforms:
                      description: List of auto-instrumentation platforms to use (must match the type of the application running in the container). Can be empty to use none. Ignored for named (non-default) CRs.
                      type: array
                      minItems: 0
                      items:
                        type: string
                        enum:
                          - DotNet
                          - Java
                          - NodeJs
                    logCollectionSettings:
                      description: >-
                        Before this configuration is applied, Azure Monitor already collects pod console output and uploads it to ConsoleLog / ConsoleLogV2 tables in the associated Log Analytics Workspace by Azure Monitor Container Insights.
                        Logs that were output via the console lose distributed tracing context and cannot be visualized in the end-to-end transaction details experience.
                        The following flags allow for configuring what works best for a particular monitoring scenario.
                      type: object
                      properties:
                        disableAppLogs:
                          description: >-
                            Controls whether logs produced by standard logging frameworks are uploaded to Application Insights.
                            Different languages may support different logging frameworks, and support will change over time.
                            Note: enabling this flag without disabling console output (either through the flag in this section or by removing the console adapters when configuring the SDK) might result in double collection of logs and higher cost.
                          type: boolean
                          default: false
                        disableContainerLogs:
                          description: >-
                            Controls whether console output from the container should be collected in the associated Log Analytics Workspace.
                            Disabling container logs collection will result in lower costs if that output is already collected by the language-specific SDK.
                            Note: if your application outputs to console using an unsupported framework, disabling container console output might result in lost logs.
                            If you have pods/containers outside of your application (such as Nginx) which output to console, setting this flag will disable output from those pods/containers as well if this CR is applied to those pods/containers.
                          type: boolean
                          default: false
                  
                destination:
                  description: Sink for telemetry data
                  type: object
                  required:
                    - applicationInsightsConnectionString
                  properties:
                    applicationInsightsConnectionString:
                      description: Connection string of the Application Insights component to send telemetry data to.
                      type: string
---
apiVersion: v1
kind: Secret
metadata: 
  name: app-monitoring-webhook-cert
  namespace: kube-system
data:
  ca.cert:  ""
  ca.key:  ""
  tls.cert:  ""
  tls.key:  ""
---
apiVersion: admissionregistration.k8s.io/v1
kind: MutatingWebhookConfiguration
metadata: 
  name: app-monitoring-webhook
  namespace: kube-system
  labels: 
    component: app-monitoring
webhooks:
  - name: app-monitoring-agent-webhook-service.kube-system.svc
    clientConfig:
      service:
        name: app-monitoring-agent-webhook-service
        namespace: kube-system
        path: "/"
      caBundle: ""
    rules:
      - operations: ["CREATE", "UPDATE"]
        apiGroups: ["*"]
        apiVersions: ["*"]
        resources: ["deployments"]  
    failurePolicy: Ignore
    sideEffects: None
    admissionReviewVersions: ["v1"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: instrumentation-crd-watcher
rules:
- apiGroups: ["monitor.azure.com"]
  resources: ["instrumentations"]
  verbs: ["get","watch","list"]
- apiGroups: [""]
  resources: ["secrets"]
  verbs: ["get", "list", "delete", "patch"]
- apiGroups: [ "admissionregistration.k8s.io"]
  resources: [ "mutatingwebhookconfigurations"]
  verbs: [ "get", "list", "delete", "patch", "create"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: app-monitoring-webhook-binding
  labels:
    component: app-monitoring
subjects:
- kind: ServiceAccount
  name: app-monitoring-webhook-sa
  namespace: kube-system
roleRef:
  kind: ClusterRole
  name: instrumentation-crd-watcher
  apiGroup: rbac.authorization.k8s.io
---
apiVersion: batch/v1
kind: Job
metadata:
  name: appmonitoring-cert-manager-hook-install
  namespace: kube-system
  labels:
    component: app-monitoring
spec:
  template:
    spec:
      serviceAccountName: app-monitoring-webhook-sa
      containers:
        - env: 
          - name: CONTAINER_MODE
            value: secrets-manager
          image: ${AIDEV_IMAGE_NAME}
          imagePullPolicy: IfNotPresent
          name: app-monitoring-cert-manager
      restartPolicy: OnFailure
---
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    component: app-monitoring
    kubernetes.azure.com/managedby: aks
  name: app-monitoring-webhook-deployment
  namespace: kube-system
spec:
  replicas: 2
  selector:
    matchLabels: 
      app: app-monitoring-webhook
  template: 
    metadata: 
      labels: 
        app: app-monitoring-webhook
    spec: 
      affinity: 
        nodeAffinity: 
          requiredDuringSchedulingIgnoredDuringExecution: 
            nodeSelectorTerms: 
            - matchExpressions: 
              - key: kubernetes.io/os
                operator: In
                values: 
                - linux
              - key: kubernetes.azure.com/cluster
                operator: Exists
              - key: type
                operator: NotIn
                values: 
                - virtual-kubelet
      tolerations:
        - key: "CriticalAddonsOnly"
          operator: "Exists"
        - operator: "Exists"
          effect: NoExecute
        - operator: "Exists"
          effect: NoSchedule
        - operator: "Exists"
          effect: PreferNoSchedule
      containers: 
      - env: 
        - name: ARM_ID
          value: /subscriptions/66010356-d8a5-42d3-8593-6aaa3aeb1c11/resourceGroups/appmonitoring-pipeline-test/providers/Microsoft.ContainerService/managedClusters/aks-pipeline-testbed-ai
        - name: ARM_REGION
          value: eastus
        image: ${AIDEV_IMAGE_NAME}
        imagePullPolicy: IfNotPresent
        name: app-monitoring-webhook
        ports: 
        - containerPort: 1337
        resources: 
          limits: 
            cpu: 200m
            memory: 200Mi
          requests: 
            cpu: 200m
            memory: 200Mi
        volumeMounts: 
        - mountPath: /mnt/webhook
          name: webhook-certs
          readOnly: true
      serviceAccount: app-monitoring-webhook-sa
      volumes: 
      - name: webhook-certs
        secret: 
          secretName: app-monitoring-webhook-cert
---
apiVersion: "v1"
kind: "ServiceAccount"
metadata: 
  labels: 
    component: app-monitoring
  name: app-monitoring-webhook-sa
  namespace: kube-system
---
apiVersion: v1
kind: Service
metadata:
  name: app-monitoring-webhook-service
  namespace: kube-system
  labels:
    component: app-monitoring
spec:
  ports:
    - port: 443
      protocol: TCP
      targetPort: 1337
  selector:
    app: app-monitoring-webhook